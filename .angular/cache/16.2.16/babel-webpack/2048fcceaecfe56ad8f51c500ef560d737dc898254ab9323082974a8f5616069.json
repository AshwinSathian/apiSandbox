{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { inject, Directive, NgModule } from '@angular/core';\nimport { MatInput } from '@angular/material/input';\nexport { MAT_INPUT_VALUE_ACCESSOR as MAT_LEGACY_INPUT_VALUE_ACCESSOR, getMatInputUnsupportedTypeError as getMatLegacyInputUnsupportedTypeError } from '@angular/material/input';\nimport { MAT_LEGACY_FORM_FIELD, MatLegacyFormFieldControl, MatLegacyFormFieldModule } from '@angular/material/legacy-form-field';\nimport { TextFieldModule } from '@angular/cdk/text-field';\nimport { MatCommonModule, ErrorStateMatcher } from '@angular/material/core';\n\n/**\n * Directive that allows a native input to work inside a `MatFormField`.\n * @deprecated Use `MatInput` from `@angular/material/input` instead. See https://material.angular.io/guide/mdc-migration for information about migrating.\n * @breaking-change 17.0.0\n */\nclass MatLegacyInput extends MatInput {\n  constructor() {\n    super(...arguments);\n    this._legacyFormField = inject(MAT_LEGACY_FORM_FIELD, {\n      optional: true\n    });\n  }\n  _getPlaceholder() {\n    // If we're hiding the native placeholder, it should also be cleared from the DOM, otherwise\n    // screen readers will read it out twice: once from the label and once from the attribute.\n    // TODO: can be removed once we get rid of the `legacy` style for the form field, because it's\n    // the only one that supports promoting the placeholder to a label.\n    const formField = this._legacyFormField;\n    return formField && formField.appearance === 'legacy' && !formField._hasLabel?.() ? null : this.placeholder;\n  }\n  static {\n    this.ɵfac = /* @__PURE__ */function () {\n      let ɵMatLegacyInput_BaseFactory;\n      return function MatLegacyInput_Factory(t) {\n        return (ɵMatLegacyInput_BaseFactory || (ɵMatLegacyInput_BaseFactory = i0.ɵɵgetInheritedFactory(MatLegacyInput)))(t || MatLegacyInput);\n      };\n    }();\n  }\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatLegacyInput,\n      selectors: [[\"input\", \"matInput\", \"\"], [\"textarea\", \"matInput\", \"\"], [\"select\", \"matNativeControl\", \"\"], [\"input\", \"matNativeControl\", \"\"], [\"textarea\", \"matNativeControl\", \"\"]],\n      hostAttrs: [1, \"mat-input-element\", \"mat-form-field-autofill-control\"],\n      hostVars: 15,\n      hostBindings: function MatLegacyInput_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"data-placeholder\", ctx.placeholder);\n          i0.ɵɵclassProp(\"mat-input-server\", ctx._isServer)(\"mat-mdc-input-element\", false)(\"mat-mdc-form-field-textarea-control\", false)(\"mat-mdc-form-field-input-control\", false)(\"mdc-text-field__input\", false)(\"mat-mdc-native-select-inline\", false)(\"mat-native-select-inline\", ctx._isInlineSelect());\n        }\n      },\n      exportAs: [\"matInput\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MatLegacyFormFieldControl,\n        useExisting: MatLegacyInput\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatLegacyInput, [{\n    type: Directive,\n    args: [{\n      selector: `input[matInput], textarea[matInput], select[matNativeControl],\n      input[matNativeControl], textarea[matNativeControl]`,\n      exportAs: 'matInput',\n      host: {\n        /**\n         * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.\n         */\n        'class': 'mat-input-element mat-form-field-autofill-control',\n        '[class.mat-input-server]': '_isServer',\n        // These classes are inherited from the base input class and need to be cleared.\n        '[class.mat-mdc-input-element]': 'false',\n        '[class.mat-mdc-form-field-textarea-control]': 'false',\n        '[class.mat-mdc-form-field-input-control]': 'false',\n        '[class.mdc-text-field__input]': 'false',\n        '[class.mat-mdc-native-select-inline]': 'false',\n        // At the time of writing, we have a lot of customer tests that look up the input based on its\n        // placeholder. Since we sometimes omit the placeholder attribute from the DOM to prevent screen\n        // readers from reading it twice, we have to keep it somewhere in the DOM for the lookup.\n        '[attr.data-placeholder]': 'placeholder',\n        '[class.mat-native-select-inline]': '_isInlineSelect()'\n      },\n      providers: [{\n        provide: MatLegacyFormFieldControl,\n        useExisting: MatLegacyInput\n      }]\n    }]\n  }], null, null);\n})();\n\n/**\n * @deprecated Use `MatInputModule` from `@angular/material/input` instead. See https://material.angular.io/guide/mdc-migration for information about migrating.\n * @breaking-change 17.0.0\n */\nclass MatLegacyInputModule {\n  static {\n    this.ɵfac = function MatLegacyInputModule_Factory(t) {\n      return new (t || MatLegacyInputModule)();\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatLegacyInputModule,\n      declarations: [MatLegacyInput],\n      imports: [TextFieldModule, MatLegacyFormFieldModule, MatCommonModule],\n      exports: [TextFieldModule,\n      // We re-export the `MatLegacyFormFieldModule` since `MatLegacyInput` will almost always\n      // be used together with `MatLegacyFormField`.\n      MatLegacyFormFieldModule, MatLegacyInput]\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [ErrorStateMatcher],\n      imports: [TextFieldModule, MatLegacyFormFieldModule, MatCommonModule, TextFieldModule,\n      // We re-export the `MatLegacyFormFieldModule` since `MatLegacyInput` will almost always\n      // be used together with `MatLegacyFormField`.\n      MatLegacyFormFieldModule]\n    });\n  }\n}\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(MatLegacyInputModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [MatLegacyInput],\n      imports: [TextFieldModule, MatLegacyFormFieldModule, MatCommonModule],\n      exports: [TextFieldModule,\n      // We re-export the `MatLegacyFormFieldModule` since `MatLegacyInput` will almost always\n      // be used together with `MatLegacyFormField`.\n      MatLegacyFormFieldModule, MatLegacyInput],\n      providers: [ErrorStateMatcher]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MatLegacyInput, MatLegacyInputModule };\n//# sourceMappingURL=legacy-input.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}